# 记录项目优化的一些技巧

## Plugins

利用一些插件进行优化

### lazy-compile-webpack-plugin

> 用于懒编译，加快项目启动速度

```js
// webpack.config.dev.js
const LazyCompilePlugin = require("lazy-compile-webpack-plugin");
const plugins = [
  new webpack.HotModuleReplacementPlugin(), // Tell webpack we want hot reloading
  new HtmlWebpackPlugin({
    inject: true, // Inject all files that are generated by webpack, e.g. bundle.js
    template: "app/index.dev.html",
    chunksSortMode: "none",
  }),
];
// package.json script中配置--lazy即可
const isLazy = process.argv.includes("--lazy");
if (isLazy) {
  plugins.push(new LazyCompilePlugin());
}
```

### circular-dependency-plugin

> 使用 circular-dependency-plugin 插件来做循环引用的检测

基本用法如下，复制、粘贴即可生效：

```js
// webpack.config.js
const CircularDependencyPlugin = require("circular-dependency-plugin");

module.exports = {
  plugins: [
    new CircularDependencyPlugin({
      // exclude detection of files based on a RegExp
      exclude: /node_modules/,
      // include specific files based on a RegExp
      include: /src/,
      //true: add errors to webpack instead of warnings
      //false: show a warning when there is a circular dependency
      failOnError: true,
      // allow import cycles that include an asyncronous import,
      // e.g. via import(/* webpackMode: "weak" */ './file.js')
      allowAsyncCycles: false,
      // set the current working directory for displaying module paths
      cwd: process.cwd(),
    }),
  ],
};
```

### progress-bar-webpack-plugin

> 在命令行中显示当前编译进度

## 技巧/HACK

### 让 webpack 只编译需要使用/调试/开发的模块

> 适用于很多个模块的大项目
> 代码如下：

```js
/**
 * WEBPACK DLL GENERATOR
 *
 * This profile is used to cache webpack's module
 * contexts for external library and framework type
 * dependencies which will usually not change often enough
 * to warrant building them from scratch every time we use
 * the webpack process.
 */
// webpack.dll.config.js
const webpack = require("webpack");
const { merge } = require("webpack-merge");
const path = require("path");

module.exports = merge({
  mode: "development",
  entry: {
    vendor: [
      "@antv/g6",
      "font-awesome/css/font-awesome.css",
      "elliptic",
      "moment",
      // ...
    ],
  },
  output: {
    path: path.resolve(__dirname, "../../build"),
    filename: "[name].dll.js",
    library: "[name]_dll_lib",
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, "../../build", "[name].manifest.json"),
      name: "[name]_dll_lib",
    }),
  ],
});
```

```json
// package.json
{
  "script": {
    "dev": "corsproxy & cross-env NODE_ENV=development webpack-dev-server --config webpack/webpack.dev.config.js --max_old_space_size=8192",
    "dll": "cross-env webpack --config webpack/webpack.dll.config.js"
  }
}
```

```js
// webpack.dev.config.js
/**
 * DEVELOPMENT WEBPACK CONFIGURATION
 */
const fs = require("fs");
const path = require("path");
const webpack = require("webpack");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const CircularDependencyPlugin = require("circular-dependency-plugin");
const ProgressBarPlugin = require("progress-bar-webpack-plugin");

const template = (() => {
  const content = fs.readFileSync(
    path.resolve(__dirname, "../../app/index.dev.html"),
    "utf-8"
  );
  return content.replace(
    '<base href="/">',
    '<base href="/"><script src="build/vendor.dll.js"></script>'
  );
})();

module.exports = require("./webpack.base.babel")({
  mode: "development",
  // Add hot reloading in development
  entry: [
    "eventsource-polyfill", // Necessary for hot reloading with IE
    "webpack-hot-middleware/client?reload=true",
    path.join(process.cwd(), "app/app.js"), // Start with js/app.js
  ],
  // entry: [path.join(process.cwd(), 'app/test.js')],
  // Don't use hashes in dev mode for better performance
  output: {
    filename: "[name].js",
    chunkFilename: "[name].chunk.js",
  },
  optimization: {
    minimize: false,
  },
  // Add development plugins
  plugins: [
    new webpack.HotModuleReplacementPlugin(), // Tell webpack we want hot reloading
    new ProgressBarPlugin(),
    new CircularDependencyPlugin({
      exclude: /a\.js|node_modules/, // exclude node_modules
      failOnError: false, // show a warning when there is a circular dependency
    }),
    new webpack.DllReferencePlugin({
      context: path.join(__dirname, "../../"),
      manifest: path.resolve(__dirname, "../../build/vendor.manifest.json"),
    }),
    new HtmlWebpackPlugin({
      // Inject all files that are generated by webpack, e.g. bundle.js
      inject: true,
      // template: 'app/index.dev.html',
      chunksSortMode: "none",
      templateContent: () => template,
    }),
  ],
  devtool: "eval-source-map",
  // devtool: 'none',
  performance: {
    hints: false,
  },
});
```

1. 原理如上：第一次编译时把一些第三方库框架等不会变动的文件啥的编译完生成 DLL 缓存起来；
2. 以后修改了某个文件只编译这个改动过的文件，其他的还是使用缓存；
3. 注意配置好编译的 dll 的文件名及路径。

## Loaders

> 记录常用 loader 及其原理&作用

### css-loader & style-loader

1. webpack 是用 JS 写的，运行在 node 环境，所以默认 webpack 打包的时候只会处理 JS 之间的依赖关系！因为像 .css 这样的文件不是一个 JavaScript 模块，你需要配置 webpack 使用 css-loader 或者 style-loader 去合理地处理它们。
2. 如果在 JS 中导入了 css，那么就需要使用 css-loader 来识别这个模块，通过特定的语法规则进行转换内容最后导出 css-loader 会处理 import / require（） @import / url 引入的内容。
3. css-loader 处理之后导出的是个数组，页面是无法直接使用，这时我们需要用到另外一个 style-loader 来处理。
4. style-loader 是通过一个 JS 脚本创建一个 style 标签，里面包含一些样式。style-loader 是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个 loader 的功能都是单一的，各自拆分独立。
5. 注意：module.rules 中，解析 css 文件时，loader 是从右往左依次执行的，所以引入时要注意顺序。

### file-loader & url-loader

1. file-loader 加载字体库文件
2. url-loader 加载图片、字体库等资源文件，一般用 url-loader 即可

### vue-loader & babel-loader & eslint-loader

特殊 loader，按需使用。

### less-loader & stylus-loader & sass-loader & scss-loader & postcss-loader

1. 顾名思义，样式文件预编译 loader.
2. use: ["style-loader", "css-loader", "postcss-loader","sass-loader"].
3. less 在编译时可以补全 css 代码的兼容性前缀.
4. postcss-loader 可以补全 css 代码的兼容性前缀.
5. 使用 autoprefixer 添加厂商前缀.
6. postcss-preset-env 包含 autoprefixer，因此如果你已经使用了 preset 就无需单独添加它了.

### image-webpack-loader

1. 项目里看到，已经废弃了，注释掉！！！

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: [
        "style-loader",
        "css-loader",
        {
          loader: "postcss-loader",
          options: {
            postcssOptions: {
              plugins: [
                [
                  "postcss-preset-env",
                  // or
                  // "autoprefixer",
                  {
                    // Options
                  },
                ],
              ],
            },
          },
        },
        {
          loader: "less-loader",
          options: {
            path: [path.resolve(__dirname, "antd")],
          },
        },
      ],
    },
    {
      test: /\.(png|svg|jpe?g)$/i,
      loader: "url-loader",
      options: {
        esModule: false,
      },
    },
    {
      test: /\.(woff|woff2|eot|ttf|otf)$/i,
      loader: "file-loader",
      options: {
        esModule: false,
      },
    },
    {
      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
      loader: "url-loader",
      options: {
        limit: 10000,
        name: utils.assetsPath("fonts/[name].[hash:7].[ext]"),
      },
    },
  ];
}
```

## 3rd Library

一些实用的 npm 包

### cors-proxy

1. 前端跨域代理，还可以配置 webpack 代理 proxy，nginx 反向代理

```bash
npm i cors-proxy -g
cors-proxy
# The cors proxy will start at http://localhost:1337. To access another domain,  # use the domain name (including port) as the first folder, e.g.
# http://localhost:1337/localhost:3000/sign_in
# http://localhost:1337/my.domain.com/path/to/resource
```

```js
module.exports = {
  //...
  devServer: {
    proxy: {
      "/api": {
        target: "http://www.baidu.com/",
        pathRewrite: {
          "^/api": "",
        },
        changeOrigin: true,
        secure: false,
      },
    },
  },
};
```

2. pathRewrite：路径重写，也就是说会修改最终请求的 API 路径。比如访问的 API 路径/api/users，设置 pathRewrite: {'^/api' : ''},后，最终代理访问的路径为：http://www.baidu.com/users，这个参数的目的是给代理命名后，在访问时把命名删除掉。
